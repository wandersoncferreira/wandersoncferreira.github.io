<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>abstraction: not what you think it is</title><link rel=stylesheet href=/css/style.css></head><body><header><a href=/>Wanderson Ferreira</a><br>-------------------------------<div style=float:right></div><br><p><nav>My small corner to publish my notes and save some
interesting readings for posterity.<br><br>This attempt will be to keep
my Zettelkasten notes public, this should impose on my writings
a little bit of more clarity and thinking.<br><br><a href=/><b>Home</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/bookmarks/><b>Bookmarks</b></a>.
<a href=/notes/><b>Notes</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p></header><main><article><h1>abstraction: not what you think it is</h1><b><time>2022-05-06 13:36:00</time></b>
<a href=/tags/raw-page>raw-page</a><div><p>March 28, 2022</p><blockquote><p>“Interfaces are abstractions”<br>&mdash; <a href=https://codecoach.co.nz/interfaces-are-abstractions/>Olaf
Thielke</a>, the &ldquo;Code Coach&rdquo;</p></blockquote><blockquote><h2 id=interfaces-are-not-abstractionsbr->“Interfaces are not abstractions”<br></h2><p><a href=https://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/>Mark
Seeman</a>, author of <span class=underline>Code that Fits in Your Head</span> and <span class=underline>Dependency
Injection</span></p></blockquote><blockquote><p>“Abstraction in programming is the process of identifying common
patterns that have systematic variations; an abstraction represents the
common pattern and provides a means for specifying which variation to
use”<br>&mdash; [[<a href=https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf>https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf</a>][Richard</p><ol><li>Gabrie]]l, author of “The Rise of Worse is Better” and _Patterns of</li></ol><p>Software_</p></blockquote><blockquote><h2 id=-windshield-wipers--abstract-away-the-weatherbr->“[&mldr;] windshield wipers [&mldr;] abstract away the weather”<br></h2><p><a href=https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/>Joel
Spolsky</a>, cofounder of Fog Creek Software, Stack Overflow, and Trello</p></blockquote><p>Of all the concepts debated in software engineering, abstraction is at
the top. I found two separate debates about it on Twitter from the past
week.</p><p>As the quoted writers show, people do not even agree what abstraction
means. Abstraction seems to stand for a hodgepodge of different concepts
involving generality, vagueness, or just plain code reuse. These
engineering debates &mdash; debates about whether duplications are better
than the wrong abstraction or about whether abstraction makes code
harder to read &mdash; trickle down into heated discussions over code. But
this confusion over abstraction&rsquo;s basic meaning makes all such debates
doomed.</p><p>This situation is particularly sad for me as someone with a background
in PL theory. There are a lot of topics in software engineering that are
the result of accumulated intuition over decades. But we&rsquo;ve had a pretty
good definition of abstraction since 1977, originally in the context of
program analysis, and &mdash; I claim &mdash; it actually translates quite well
into a precise definition of “abstraction” in engineering.</p><p>Abstraction in general is usually said to be something which helps
readers understand code without delving into the details. Yet, for many
of the concrete code examples programmers actually call “abstraction,”
they can be (and are) used in ways which add details and hinder
understanding. In opposition, I take the position that software
engineers will benefit from studying the mathematics of PL-theoretic
abstraction, understanding how it explains things they already do, and
letting this coherent definition rule their use of the term
&ldquo;abstraction.&rdquo;</p><p>My initial goal in this post is a smaller enabling step: to give you
names for the other concepts that are often combined under the name
&ldquo;abstraction&rdquo; that they may be referenced, used, and critiqued
specifically, and to help you move away from the vague and contradictory
<a href=https://www.pathsensitive.com/2018/12/my-strange-loop-talk-you-are-program.html>citrus
advice</a> that arises from using the same name for different things. From
there, I will proceed to provide the rigorous definition of abstraction
as it pertains to software, followed by concrete examples.</p><p>But the story does not end after separating true abstractions from their
impostors. The endless debates over what is and isn&rsquo;t an abstraction
shall be resolved in an unsatisfying way: almost anything can be viewed
as an abstraction, and most abstractions are useless. Yet once you learn
how to actually write down an abstraction mapping, you gain the ability
to look beyond the binary and explain the exact benefit that a given
abstraction does or does not provide a reasoner, and in doing so
rearrange the discordant intuition around abstraction into harmonic
lines of precise, actionable advice.</p><h2 id=not-abstraction>Not Abstraction</h2><p>There are at least five other things that go under the name abstraction.</p><h3 id=functions>Functions</h3><p>One contender for the oldest programming language is the lambda
calculus, where Alonso Church showed us that, by copying symbols on
pen-and-paper using a single rule, one could compute anything.</p><p>In the lambda calculus, making a new function is called “lambda
abstraction,” and often just “abstraction.”</p><p>By &ldquo;making a new function,&rdquo; that doesn&rsquo;t mean that it&rsquo;s the process of
looking at two similar terms like sin(x)<sup>2</sup>+1 and 2*x+1, and deciding
to make a function λx.x+1. That&rsquo;s anti-unification, described below. It
is quite literally the process of taking x+1 and changing it to λx.x+1.</p><p>And “abstraction” also refers to the output of this process, i.e.: any
lambda/function whatsoever.^1</p><p><a href=https://cs.stackexchange.com/questions/93006/why-is-abstraction-in-lambda-calculus-called-abstraction>It&rsquo;s
been noted</a> that this use of the word &ldquo;abstraction&rdquo; is quite different
from other uses. Unfortunately, this has polluted broader discussion.
Even though the lambda calculus usage is akin to adding an opening and
closing brace to a block of code, this usage leaks out into discussion
of &ldquo;abstracting things into functions&rdquo; and from there into extolling the
benefits of being able to ignore details and other things that closing
braces really don&rsquo;t let you do.</p><p>So functions are abstractions &mdash; just in a very limited meaning of the
word with little relation to everything else under that label. Moving
on&mldr;</p><h3 id=anti-unification>Anti-unification</h3><p>&ldquo;<a href=https://en.wikipedia.org/wiki/Anti-unification_(computer_science)>Anti-unification</a>&rdquo;
is a fancy term for the process of taking two things that are mostly
similar, and replacing the different parts with variables. If you
substitute those variables one way, you get the first thing back; else
you get the second. If you see x*x and (a-b)*(a-b) near each other in a
codebase and extract out a square function, then you&rsquo;ve just done an
anti-unification (getting the pattern A*A with the two substitutions [A
↦ x] and [A ↦ a*b]).</p><p>(Its opposite is
<a href=https://en.wikipedia.org/wiki/Unification_(computer_science)>unification</a>,
which is comparatively never used in programming. Unless you&rsquo;re writing
Prolog, in which case, it&rsquo;s literally on every single line.)</p><p>This probably looks familiar: virtually all of what goes under the Don&rsquo;t
Repeat Yourself label is an example of anti-unification. Perhaps you
would describe the above as &ldquo;abstracting out the square function&rdquo;
(different from the previous definition, where &ldquo;abstracting&rdquo; is just
adding curly braces after the variables are already in place).</p><p>In fact, Eric Elliott, author of <span class=underline>Composing Software</span> and <span class=underline>Programming
JavaScript Applications</span>
<a href=https://ericelliottjs.com/premium-content/abstraction-and-composition>goes
as far as to say</a> “abstraction is the process of simplifying code by
finding similarities between different parts of the code and extracting
shared logic into a named component (such as a function, module,
etc&mldr;)” &mdash; i.e.: that abstraction is anti-unification. He then
<a href=https://medium.com/javascript-scene/the-secret-of-simple-code-a2cacd8004dd%0A>goes
on to claim</a> &ldquo;The secret to being 10x more productive is to gain a
mastery of abstraction.&rdquo; That sounds pretty impressive for a process
which was
<a href=https://homepages.inf.ed.ac.uk/gdp/publications/MI5_note_ind_gen.pdf>first
automated in 1970</a>. ^2</p><h3 id=boxing>Boxing</h3><p>&ldquo;Boxing&rdquo; is what happens when you do too much anti-unification: a bunch
of places with syntactically-similar code turns into one big function
with lots of conditionals and too many parameters. &ldquo;Boxing&rdquo; is a term of
my own invention, though I can&rsquo;t truly claim credit, as the &ldquo;stuffing a
mess into a box&rdquo; metaphor predates me. Preventing this is exactly the
concern expressed in the line
&ldquo;<a href=https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction>duplication
is better than the wrong abstraction</a>,&rdquo; as
<a href=https://www.codewithjason.com/duplication-cheaper-wrong-abstraction/>clarified</a>
by a critic.</p><p>There&rsquo;s a surefire sign that boxing has occurred. Sandi Metz describes
it nicely:</p><blockquote><p>Programmer B feels honor-bound to retain the existing abstraction, but
since [it] isn&rsquo;t exactly the same for every case, they alter the code to
take a parameter, and then add logic to conditionally do the right thing
based on the value of that parameter.</p></blockquote><p>I&rsquo;ve
<a href=https://www.pathsensitive.com/2018/01/the-design-of-software-is-thing-apart.html>written</a>
and
<a href=https://corecursive.com/036-jimmy-koppel-advanced-software-design/>spoken</a>
against this kind of naive de-duplication before. One of the first
exercises in my course is to give two examples of code that have the
same implementation but a different spec (and should therefore evolve
differently). Having identical code is not a foolproof measure that two
blocks do the same thing, and it&rsquo;s helpful to have different terminology
for merging similar things that do and do not go together.</p><p>But, particularly, if we want abstraction to have something to do with
being able to ignore details, we have to stop calling this scenario
&ldquo;abstraction.&rdquo;</p><h3 id=indirection>Indirection</h3><p>Though not precisely defined, indirection typically means &ldquo;any time you
need to jump to another file or function to see what&rsquo;s going on.&rdquo; It&rsquo;s
commonly associated with Enterprise Java, thanks to books such as
Fowler&rsquo;s Patterns of Enterprise Application Architecture, and is
exemplified by the Spring framework and parodied by
<a href=https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition>FizzBuzz:
Enterprise Edition</a>. This is where you get people complaining about
&ldquo;layers&rdquo; of abstraction. It commonly takes the form of long chains of
single-line functions calling each other or class definitions split into
a hierarchy across 7 files.</p><p>Fowler&rsquo;s examples include abstracting</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>contract.calculateRevenueRecognition()
</span></span></code></pre></div><p>into the Service Layer Abstraction™</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>calculateRevenueRecognition(Contract)
</span></span></code></pre></div><p>If you were to describe the former, you&rsquo;d probably say &ldquo;It calculates
the recognized revenue for the contract.&rdquo; If you were to describe the
latter, you&rsquo;d probably say &ldquo;It calculates the recognized revenue for the
contract.&rdquo; We&rsquo;ve been spared no details.</p><h3 id=interfaces-typeclasses-and-parametric-polymorphism>Interfaces, Typeclasses, and Parametric Polymorphism</h3><p>All three of these are mechanisms for grouping multiple function
implementations so that a single invocation may dispatch to any of them.
Most programmers will be familiar with interfaces, which are a language
feature in Java and TypeScript and a common pattern in Python.
Typeclasses, a.k.a. “traits,” are essentially interfaces not attached to
objects. Parametric polymorphism, a.k.a. “generics,” are a little
different in that they combine functions which differ in nothing but
their type signature.</p><p>Parametric polymorphism is essentially just adding an extra parameter to
a function, except that this extra parameter is a type. It&rsquo;s not
abstraction in the same way that anti-unification isn&rsquo;t.</p><p>Interfaces and typeclasses do tend to be associated with abstractions in
the sense about to be introduced. But there&rsquo;s a banal reason they do not
satisfy the goal of an abstraction definition: there&rsquo;s nothing mandating
that the many implementations have anything to do with each other. For
example, in my installation of the Julia language, the getindex function
is actually an interface with 188 implementations, dispatched based on
the runtime type of its arguments. Most of these implementations do
lookups into array-like structures, but a few do the exact opposite and
create an array.</p><p>Sometimes, when calling a function behind a polymorphic typeclass
interface, the programmer knows only one implementation is relevant, so
the shared name is just to save some typing. Other than that, in order
to make use of any of these, one must be able to explain the operation
of multiple functions in some common language. It is not the language
feature that allows one to program liberated from details, but rather
this common language and its correspondence with each of the
implementations. Which brings us to&mldr;</p><h2 id=true-abstraction>True Abstraction</h2><p>In programming language theory and formal methods, there are several
definitions of &ldquo;abstraction&rdquo; in different contexts, but they are all
quite similar: abstractions are mappings between a complex concrete
world and a simple idealized one. For concrete data types, an
abstraction maps a complicated data structure to the basic data it
represents. For systems, an abstraction relates the tiny state changes
from every line implementing a TCP stack with the information found in
the actual protocol diagram. These abstractions become useful when one
can define interesting operations purely on the abstract form, thus
achieving the dictum of Dijkstra, that &ldquo;The purpose of abstraction is
not to be vague, but to create a new semantic level in which one can be
absolutely precise.&rdquo;</p><p>You&rsquo;ve probably used one such abstraction today: the number 42 can be
represented in many forms, such as with bits, tally marks, and even (as
is actually done in mathematics)
<a href=https://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers>as
a set</a>. Addition has correspondingly many implementations, yet you need
not think of any of them when using a calculator. And they can be
composed: there is an abstraction to the mathematical integers from
their binary implementation, and another abstraction to binary from the
actual voltages. In good abstractions, you&rsquo;ll never think that it&rsquo;s even
an abstraction.</p><p>So, what do abstractions actually look like in code?</p><p>They don&rsquo;t.</p><h3 id=where-are-the-abstractions>Where are the abstractions?</h3><p>A running joke in my software design course is that, whenever I show
some code and ask whether it has some design property, the answer is
always &ldquo;maybe.&rdquo; And so it is whenever you ask &ldquo;Is Y an abstraction of
X?&rdquo;</p><p>First, a quick digression. In PL theory and formal methods, there are
many definitions of abstraction in different contexts, though they are
all far more similar to each other than to any of the not-abstractions
in previous sections. The one I am about to present is based on the
theory of
<a href=https://en.wikipedia.org/wiki/Abstract_interpretation>abstract
interpretation</a>. Abstract interpretation is usually taught as a (very
popular) approach to static analysis, where it&rsquo;s used to write tools
that can, say, prove a program never has an array-out-of-bounds access.
But it can also be applied to more interesting properties, though
usually in a less automated fashion. I&rsquo;ll be presenting it from the
perspective of understanding programs rather than building tools, and
explaining it without math symbols and Greek letters. I&rsquo;ll be in
particular focusing on abstracting program state. I&rsquo;ll occasionally
gesture at abstracting steps in a program, though the actual definitions
are more complicated. (Google “simulation relation” and “bisimulation”
to learn the technical machinery.)</p><p>So:</p><p>Abstractions are mappings. An abstraction is a pattern we impose on the
world, not the entities it relates, which are called the abstract domain
and concrete domain. Strictly adhering to this definition, the
well-formed question would be &ldquo;Is there an abstraction from X to Y?&rdquo;
followed by “Is that abstraction good?”</p><p>Let&rsquo;s return to the example of numbers. There is a great abstraction
from voltages in hardware to strings of 0&rsquo;s and 1&rsquo;s, from strings of 0&rsquo;s
and 1&rsquo;s to mathematical numbers, and also from tally marks to numbers.
These abstractions on numbers induce abstracted versions of each
operation on the base representations, such as the very-simple operation
of adding 1 to a number. Already, we can see that the abstractions live
outside the system; computers function just fine without a device that
reads an exact value for the voltage in each transistor and then prints
out the represented number. Yet in spite of living outside the system,
this mapping is perfectly concrete.</p><h3 id=evaluating-abstractions>Evaluating abstractions</h3><p>The three example abstractions above have two properties that make them
useful. The first is <em>soundness</em>. The picture above is what&rsquo;s called a
“commutative diagram” in that any path through the diagram obtains the
same result: given an input set of voltages, it would be equivalent to
either (a) run a circuit for adding one and then convert the resulting
voltages to a number, or (b) convert the voltages to a number and then
add 1 with pen-and-paper. The second is <em>precision</em>: Adding 1 to a
number produces exactly one result, even though it corresponds to a
diverse set of output voltages.</p><p>Precision is what makes finding good abstractions nontrivial. The
eagle-eyed reader might notice that any function to the integers yields
a sound abstraction. For example, there is an abstraction from your TV
screen to integers: the serial number. However, you&rsquo;d be hard pressed to
find any operations on TVs that can be sanely expressed on integers.
Turning the TV on or changing the channel leaves it with exactly the
same serial number, while replacing the TV with one slightly larger is
barely distinguishable from randomly scrambling the serial number.
Indeed, one would likely implement the “slightly larger TV” function on
the abstract domain of serial numbers by mapping each serial number to
the set of all other serial numbers. This is sound &mdash; getting a larger
TV and then taking its serial number is certainly contained in the
result of looking at your current TV&rsquo;s serial number then applying this
operation &mdash; but maximally imprecise.</p><p>A consequence of this: if we translate every question “is X an
abstraction of Y” to “is there an abstraction which maps X to Y,” the
answer is always “yes.” Instead, we can ask <em>which operations</em> can be
<em>tracked precisely</em> with reference only to the abstract domain. The
abstraction from voltages to numbers is perfectly precise for all
operations on numbers, but not for determining whether a certain
transistor in the adder circuit contains 2.1 or 2.2 volts. The
abstraction from TVs to serial numbers is perfectly imprecise for every
operation except checking whether two TV&rsquo;s are the same (and maybe also
getting their manufacturer and model).</p><p>To the property of soundness and the measurement of precision, we add a
third dimension on which to evaluate abstractions: the size (in bits) of
an abstract state. The good abstractions are then the sound abstractions
which are small in bits, yet precise enough to track many useful
operations.</p><p>So consider a website for booking tables at restaurants, where the
concrete domain is the actual state of bookings per table
{table1BookedFrom: [(5-6 PM, “Alice”), (7-8 PM, “Bob”)], &mldr;,
table10BookedFrom: [&mldr;]}. The abstract domain shall be a list of
timeslots. For each user, it is possible to abstract a concrete state
down to the abstract state listing the booked timeslots for that user,
i.e.: for Bob, [7-8 PM]. What makes this an abstraction, as opposed to
just an operation on the restaurant state, is that we shall then proceed
to describe the effect of every other operation on this value. So
consider the actual booking function, which might have this signature:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>void bookTable(User u, TimeInterval t)
</span></span></code></pre></div><p>Below I give 4 specifications for this function. For the example of
booking a table for Carol from 7 to 8 PM, these specifications give:</p><ol><li>The actual behavior of this implementation, say, trying to assign
Carol to the lowest-numbered table.</li><li>All allowed behaviors on the concrete states, i.e.: finding any table
open at the given time and assigning it to Carol, or doing nothing if
there is none</li><li>The allowed outputs on the abstract domain of Carol&rsquo;s bookings,
namely (assuming Carol does not already have a reservation) either
[7-8 PM] or [].</li><li>The allowed outputs on the abstract domain for Bob or any other user,
i.e.: the exact same as the input.</li></ol><p>From this one example, we can derive quite a few lessons, including:</p><ul><li><strong>All of these specifications are useful</strong> in that you might use each of
them when mentally stepping through the code. Perhaps you&rsquo;d think
“This line shouldn&rsquo;t have affected any of Bob&rsquo;s bookings” (using
specification 4, corresponding to the “Bob&rsquo;s bookings” abstraction) or
“When I click this button, either table 5, 6, or 7 will be booked”
(using specification 2).</li><li><strong>Abstractions are separate from the code, and even from the abstract
domain.</strong> It does not make sense to say that the bookTable function or
anything else in this file “is” the abstraction, because, as we have
just seen, we can use many different abstractions when describing its
behavior. More striking, we see that, even for a specific pairing of
concrete and abstract domains, there can be many abstractions between
them.</li><li><strong>Instead, code is <em>associated</em> with abstractions.</strong> Note the plural.
We&rsquo;ve seen that bookTable can be associated with several abstractions
of the behavior &mdash; infinitely many in fact, including many useful
ones not previously discussed, like mapping the restaurant state to
the list of timeslots with available tables.</li><li><strong>No code change is needed to reason using an abstraction.</strong> We could
extend the mapping from relating abstract/concrete states to relating
steps between them, and then say the bookTable function “abstracts”
the set of intermediate steps the program takes for each line in the
function, but we could do this almost as easily if the bookTable
implementation was actually a blob in a much larger function.</li><li><strong>Different abstractions tend not to be more or less precise than each
other, just differently precise.</strong> Compare the abstractions from the
restaurant state to Bob&rsquo;s bookings, Carol&rsquo;s bookings, and the set of
open timeslots. All of them can be used to answer different questions.</li></ul><p>Continuing, we can also evaluate what makes the “Carol&rsquo;s bookings”
abstraction a good one. The corresponding specification, Specification
3, is quite close to deterministic, yielding only two possible output
states. The corresponding abstract states contain much less information
than the concrete ones. And an entity (human or tool) reading the code
tracking only this abstract state will still be able to perfectly
predict the result of several other operations, such as checking whether
Carol has a table. This is the <strong>new semantic layer on which one can be
absolutely precise</strong> that Dijkstra speaks of!</p><p>Of course, it is cumbersome to say “there is a sound and precise
abstraction mapping voltages on hardware to mathematical numbers” or
“there is a good abstraction from the specific details of when tables
are booked to just the available times.” It is quite convenient
shorthand to use the more conventional phrasing “numbers abstract the
hardware” or “bookTable abstracts all the details of reservations;” you
can say “abstraction mapping” if you want to clearly refer to
abstractions as defined in this blog post. Yet this shorthand invites
multiple interpretations, and can spiral into an argument about whether
booking tables should actually be the same abstraction as booking hotel
rooms. Feel free to call numbers an abstraction of the hardware, but be
prepared to switch to this precise terminology when there&rsquo;s tension on
the horizon.</p><h2 id=whence-the-confusion>Whence the Confusion</h2><p>Programmers correctly intuit that it is desirable to have some way to
reason about code while ignoring details. In their 1977 paper, Patrick
and Radhia Cousot first taught us the precise definition of abstraction
that makes this possible. The other attempts fail to see the incorporeal
nature of abstractions and instead fixate on something in the code. But
there must be some connection.</p><p>Yes, functions are not abstractions. But for every function, there is an
abstraction, not necessarily a good one, collapsing the many
intermediate steps of the function into an atomic operation. There may
also be abstractions which admit a simple description of the relation
between the inputs and outputs.</p><p>Anti-unification is not abstraction. Yet two code snippets that could be
fruitfully semantically modeled with similar abstract states will often
be amenable to syntactic anti-unification. As disparate operations are
combined, ever more information must be added into the abstract state to
maintain precision. The result is boxing.</p><p>Indirection is hella not abstraction, though similarly-named functions
may suggest slightly-different abstract domains associated with them.
Many changes that make abstractions more explicit come with indirection,
but we&rsquo;ve seen it&rsquo;s possible for readers to impose abstractions on code
without any changes at all.</p><p>Typeclasses and interfaces are not abstraction, but a good interface
will be associated with at least one good abstract domain precise enough
to make each of the interface&rsquo;s operations nearly deterministic (or at
least simple to specify), and each implementation will come with a sound
abstraction mapping its concrete states into that abstract domain.</p><p>Your car&rsquo;s windshield wipers and roof do not abstract away the rain, as
claims Spolsky, but they do mean that, to predict your happiness after
running your brain&rsquo;s DriveToStore() function, you can use an abstract
state that does not include the weather.</p><p>Abstractions offer the dream of using simple thoughts to conjure
programs with rich behavior. But fulfilling this promise lies beyond the
power of any language feature, be it functions or interfaces. We must
think more deeply and identify exactly how the messy world is being
transformed into a clean ideal. We must look beyond the binary of
whether something is or is not an abstraction, and discover the new
semantic level on which we can be absolutely precise.</p><h2 id=appendix-some-other-views-of-abstraction>Appendix: Some Other Views of Abstraction</h2><p>Abelson and Sussman&rsquo;s Structure and Interpretation of Computer Programs
is a sure candidate for the title of “Bible of computer programming”
(sometimes <a href=https://kingjamesprogramming.tumblr.com/>mixed with the
actual Bible</a>), and it&rsquo;s full of instruction on abstraction, beginning
with chapter 1 “Building Abstractions with Procedures.” I expect at
least one reader wants beat me over the head with a copy of the book
saying I&rsquo;m getting it wrong. I don&rsquo;t really want that (it&rsquo;s 900 pages),
so I walked down 2 flights of stairs from my MIT office to Gerry
Sussman&rsquo;s office and asked him. I&rsquo;ll represent his ideas below.</p><p>Sussman explained that he believes abstraction is a “suitcase term”
which means too many different things, though he only sees two main uses
relevant to software. The first definition is: giving names to things
produced by the second definition. That second definition, he explained,
has to do with the
<a href=https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms>fundamental
theorem of homomorphisms</a> and its
<a href=https://en.wikipedia.org/wiki/Isomorphism_theorems#Theorem_A_(universal_algebra)>generalization</a>.
And then he pulled an abstract algebra book off the shelf.</p><p>I&rsquo;ll try to explain this as best I can with minimal math jargon while
still being precise. I&rsquo;ll explain the definition simultaneously with
Sussman&rsquo;s two examples, multivariate polynomials, and (physical)
resistors in electric circuits.</p><p>In this picture, G can be seen as the set of all data in all forms and f
is some operation on G. So G can be the set of all polynomials in all
representations, or the set of all resistors. f then can be the
operation of plotting the polynomial on all values, or computing the
current through a resistor across a range of voltages.</p><p>Now, there are many different values in G on which f does the same
thing. G contains both sparse and dense representations of the same
polynomial; these have the same plot. There are different resistors with
the same resistance; assuming they perfectly follow Ohm&rsquo;s Law, they have
the same current at the same voltage. One can write down the list of
lists of which values of G are treated the same by f; that&rsquo;s φ, the
kernel of f. So for polynomials, φ would be the list of distinct
polynomials, each of which contains the list of all representations of
that polynomial.</p><p>Now, finally, on can use φ to quotient or “smush” together the like
elements of G. All the different representations of the same polynomial
get mapped to something representing that polynomial independent of
representation. All the different resistors of resistance R get mapped
to the idea of a resistor with resistance R. This is G/K in the picture.</p><p>The theorem is then that G/K behaves the same (is isomorphic to) H,
e.g.: that that the set of different representations of polynomials can
be manipulated in the same way as their plot. But I believe Sussman was
gesturing less at this theorem and more at G/K itself, i.e.: at the idea
of merging together different representations that behave the same under
some operations.</p><p>I like this idea because it gives a way to unify into a single mapping
the relation between many different implementations and their shared
abstract domain. For the different representations of polynomials, a
typical formulation with abstract interpretation would provide a
different mapping from each kind of implementation into the shared
abstract domain. On the whole though, the operative idea in the
“homomorphism theorem” theory of abstraction seems to be that of merging
together concrete values that can be treated similarly by certain
operations. This idea is already present in abstract interpretation;
indeed, φ can be directly taken to be an abstraction mapping, with G and
G/K the concrete and abstract domains. On the whole, while I find the
connection to abstract algebra cute, I&rsquo;m not sure that the “homomorphism
theory of abstraction” offers any insight that the theory of abstract
interpretation does not.</p><p>So that&rsquo;s the main item in Sussman&rsquo;s suitcase of meanings of abstraction
in software. It looks superficially different from any of the variations
of abstract interpretation, but is actually quite compatible.</p><p>Is there anything else in that suitcase? Any other (good) uses of the
word “abstraction” not captured by the previous definitions?</p><p>Maybe. I can say that there are is something I&rsquo;d like to be able to do
with something called “abstraction,” but that I can&rsquo;t do with abstract
interpretation: dealing with inaccuracy.</p><p>You see, the orthodox definition of a sound abstraction would rule out a
technique that predicts the concrete output perfectly 99.99% of the time
and is otherwise slightly off, and instead prefers a function that says
“It could be anything” 100% of the time. I know there is work extending
abstract interpretation to some kinds of error, namely for numeric
approximations of physical quantities, but, overall, I just don&rsquo;t know a
good approach to abstraction that allows for reasonable error.</p><p>On a related note, sometimes AI researchers also talk about abstraction.
I know that the
<a href=https://www.cs.cmu.edu/~noamb/papers/17-IJCAI-Libratus.pdf>best poker
AIs</a> “abstract” the state space of the game, say by rounding all bet
sizes to multiple of $5, and that human pros exploit it by using weird
bet sizes and letting the rounding error wipe out its edge. But I am not
aware of a general theory backing this beyond just “make some
approximations and hope the end result is good,” and am not even sure
“abstraction” is a good term for this.</p><p><strong>Acknowledgments</strong></p><p>Thanks to Nate McNamara, Benoît Fleury, Nils Eriksson, Daniel Jackson,
and Gerry Sussman for feedback and discussion on earlier drafts of this
blog post.</p><hr><ol><li>Daniel Jackson credits Turing Laureate Barbara Liskov with</li></ol><p>promulgating this usage. Her influential CLU language uses “abstraction”
to mean any unit of functionality (type, procedure, or iterator).</p><ol><li>Technically, it&rsquo;s only first-order anti-unification,</li></ol><p>equivalent to extracting named constants, that Gordon Plotkin developed
in 1970. Work on higher-order anti-unification, which corresponds to
extracting (higher-order) functions, began in 1990; Feng and Muggleton&rsquo;s
“Towards Inductive Generalisation in Higher order Logic" (1992) provides
an early discussion. While Elliott is quite explicit that any
anti-unification is abstraction, it is true that there are a vast number
of anti-unifications of a given set of programs, and choosing the best
is very difficult. <a href=https://arxiv.org/abs/2006.08381>DreamCoder</a> is a
recent notable work based on doing so.</p><h3 id=liked-this-post>Liked this post?</h3><br><ul><li><p>Related Articles</p><p><span class=org-target id=org-target--comments></span>
<span class=org-target id=org-target--comments></span></p></li></ul><ul><li><p>7 comments:</p><p><span class=org-target id=org-target--comment-holder></span></p><ol><li><p><span class=org-target id=org-target--c4782714983878326947></span></p><figure><img src=//www.blogger.com/img/blogger_logo_round_35.png></figure><p><a href=https://www.blogger.com/profile/14002956273801060588>Jason</a><a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html?showComment=1648575340644#c4782714983878326947">March
29, 2022 at 1:35 PM</a></p><p>> Indirection is hella not abstraction<br><br>The identity abstraction (or any relabeling abstraction) is still
abstraction. It&rsquo;s just not good.</p><p>Reply<a href="https://www.blogger.com/delete-comment.g?blogID=8584948780979499548&postID=4782714983878326947">Delete</a></p><p><span class=org-target id=org-target--c4782714983878326947-rt></span>
Replies</p><p><span class=org-target id=org-target--c4782714983878326947-ce></span></p></li><li><p><span class=org-target id=org-target--c122527442434227251></span></p><figure><img src=//www.blogger.com/img/blogger_logo_round_35.png></figure><p><a href=https://www.blogger.com/profile/04647682047426960672>Viljami</a><a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html?showComment=1648703682748#c122527442434227251">March
31, 2022 at 1:14 AM</a></p><p>> On a related note, sometimes AI researchers also talk about
abstraction. I know that the best poker AIs “abstract” the state
space of the game, say by rounding all bet sizes to multiple of $5,
and that human pros exploit it by using weird bet sizes and letting
the rounding error wipe out its edge. But I am not aware of a general
theory backing this beyond just “make some approximations and hope
the end result is good,” and am not even sure “abstraction” is a good
term for this.<br><br>I think those are called abstraction heuristics.</p><p>Reply<a href="https://www.blogger.com/delete-comment.g?blogID=8584948780979499548&postID=122527442434227251">Delete</a></p><p><span class=org-target id=org-target--c122527442434227251-rt></span>
Replies</p><ol><li><p><span class=org-target id=org-target--c4398178886831740087></span></p><figure><img src=//www.blogger.com/img/blogger_logo_round_35.png></figure><p><a href=https://www.blogger.com/profile/00605996177342825315>James
Koppel</a><a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html?showComment=1648708003427#c4398178886831740087">March
31, 2022 at 2:26 AM</a></p><p>Useful keyword; thanks!<br><br>One of the first results I found:
<a href=http://users.cecs.anu.edu.au/~patrik/publik/absh-tutorial-2008.pdf>http://users.cecs.anu.edu.au/~patrik/publik/absh-tutorial-2008.pdf</a><br><br>&ldquo;An abstraction is a mapping, ϕ, from (states of)<br>S to some abstract space AS, which preserves labelled paths<br>and goal states."<br><br>This looks quite close to the abstract-interpretation definition I
gave in this post, and identical the definition of a simulation
relation.<br><br>I was about to say that I don&rsquo;t think the &ldquo;round to $5&rdquo; mapping
satisfies this definition. But now I realize that it can, for the
same reason the floor function is an abstraction (from the reals
to the integers).</p><p><a href="https://www.blogger.com/delete-comment.g?blogID=8584948780979499548&postID=4398178886831740087">Delete</a></p><p><span class=org-target id=org-target--c4398178886831740087-rt></span>
Replies</p><p><span class=org-target id=org-target--c4398178886831740087-ce></span></p></li></ol><p><span class=org-target id=org-target--c122527442434227251-ce></span></p></li><li><p><span class=org-target id=org-target--c8018638081176985264></span></p><figure><img src=//resources.blogblog.com/img/blank.gif></figure><p>Anonymous<a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html?showComment=1648859530319#c8018638081176985264">April
1, 2022 at 8:32 PM</a></p><p>I&rsquo;d think you&rsquo;ll broaden your audience if you start from how the word
&ldquo;abstraction&rdquo; originated in the philosophical context, then got used
in fields of art (&ldquo;abstractionism&rdquo;), literature, and then in turn
engineering and programming.</p><p>Reply<a href="https://www.blogger.com/delete-comment.g?blogID=8584948780979499548&postID=8018638081176985264">Delete</a></p><p><span class=org-target id=org-target--c8018638081176985264-rt></span>
Replies</p><p><span class=org-target id=org-target--c8018638081176985264-ce></span></p></li><li><p><span class=org-target id=org-target--c5956430403847502915></span></p><figure><img src=//www.blogger.com/img/blogger_logo_round_35.png></figure><p><a href=https://www.blogger.com/profile/04094769764887557424>Rasmus
Källqvist</a><a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html?showComment=1649002868768#c5956430403847502915">April
3, 2022 at 12:21 PM</a></p><p>I agree with the anonymous post above. Excellent text about how to
perhaps better use abstractions, but I found the argument lacking in
why the common usages of the word are &ldquo;wrong&rdquo;. Wrong because they&rsquo;re
not the same as PL people use them? PL people did not invent this
word, so I would have liked to see this framed more as &ldquo;this would be
a more precise and useful definition of abstraction than is often
used&rdquo;</p><p>Reply<a href="https://www.blogger.com/delete-comment.g?blogID=8584948780979499548&postID=5956430403847502915">Delete</a></p><p><span class=org-target id=org-target--c5956430403847502915-rt></span>
Replies</p><ol><li><p><span class=org-target id=org-target--c2742654491815920858></span></p><figure><img src=//www.blogger.com/img/blogger_logo_round_35.png></figure><p><a href=https://www.blogger.com/profile/00605996177342825315>James
Koppel</a><a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html?showComment=1649011413784#c2742654491815920858">April
3, 2022 at 2:43 PM</a></p><p>&lsquo;I would have liked to see this framed more as &ldquo;this would be a
more precise and useful definition of abstraction than is often
used&rdquo;&rsquo;<br><br>??<br><br>I think that&rsquo;s basically what I say. The first half is dedicated
to showing how each of the not-abstraction uses break down when
examined and don&rsquo;t actually comport with the desired property of
abstraction of allowing one to ignore details.</p><p><a href="https://www.blogger.com/delete-comment.g?blogID=8584948780979499548&postID=2742654491815920858">Delete</a></p><p><span class=org-target id=org-target--c2742654491815920858-rt></span>
Replies</p><p><span class=org-target id=org-target--c2742654491815920858-ce></span></p></li><li><p><span class=org-target id=org-target--c6807590335406116782></span></p><figure><img src=//www.blogger.com/img/blogger_logo_round_35.png></figure><p><a href=https://www.blogger.com/profile/04094769764887557424>Rasmus
Källqvist</a><a href="https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html?showComment=1649167825709#c6807590335406116782">April
5, 2022 at 10:10 AM</a></p><p>This comment has been removed by the author.</p><p><a href="https://www.blogger.com/delete-comment.g?blogID=8584948780979499548&postID=6807590335406116782">Delete</a></p><p><span class=org-target id=org-target--c6807590335406116782-rt></span>
Replies</p><p><span class=org-target id=org-target--c6807590335406116782-ce></span></p></li></ol><p><span class=org-target id=org-target--c5956430403847502915-ce></span></p></li></ol><p><span class=org-target id=org-target--top-continue></span>
Add comment</p><p><span class=org-target id=org-target--top-ce></span></p><p>Load more&mldr;</p><p><span class=org-target id=org-target--comment-form></span>
[[<a href="https://www.blogger.com/comment/frame/8584948780979499548?po=771403918924813779&hl=en">https://www.blogger.com/comment/frame/8584948780979499548?po=771403918924813779&hl=en</a>][]]</p><p><span class=org-target id=org-target--backlinks-container></span></p><p><span class=org-target id=org-target--Blog1-backlinks-container></span></p><p><span class=org-target id=org-target--blog-pager></span>
<a href=https://www.pathsensitive.com/2021/03/developer-tools-can-be-magic-instead.html>Older
Post →</a> <a href=https://www.pathsensitive.com/>Home</a></p><p><span class=org-target id=org-target--sidebar></span></p><p><span class=org-target id=org-target--Text1></span></p></li></ul></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/bookmarks/the_other_kind_of_staff_software_engineer/>the other kind of staff software engineer</a></li><li><a href=/notes/how_can_i_achieve_programming_mastery/>how can I achieve programming mastery?</a></li><li><a href=/notes/ability_to_acquire_knowledge/>ability to acquire knowledge</a></li><li><a href=/notes/ability_to_solve_problems/>ability to solve problems</a></li><li><a href=/notes/thought_leaders/>thought-leaders</a></li></ul></div></div></aside><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//bartuka.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><footer><p>&copy; 2022 <a href=https://wandersoncferreira.github.io><b>Wanderson Ferreira</b></a>.
<a href=https://github.com/wandersoncferreira><b>Github</b></a>.
<a href=https://twitter.com/bartuka_><b>Twitter</b></a>.</p></footer></body></html>