<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Thoughts on things">
    
    <link rel="shortcut icon" href="https://wandersoncferreira.github.io/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.250df4aa82162a2c5a9d6eb446907e3132c4226dde8db0dd884556325b734ddf.css" integrity="{{ $css.Data.Integrity }}">

    <title>Y Combinator</title>
</head>
<body><header id="banner">
    <h2><a href="https://wandersoncferreira.github.io">Bartuka</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/blog" title="blog">Blog</a>
            </li><li>
                <a href="/notes/" title="notes">Notes</a>
            </li><li>
                <a href="/projects/" title="projects">Projects</a>
            </li><li>
                <a href="/about/" title="about">About</a>
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Y Combinator</h1><time>August 26, 2018</time></header>
    
 
 <a href="https://wandersoncferreira.github.io/tags/functional/">functional</a> <a href="https://wandersoncferreira.github.io/tags/clojure/">clojure</a>



<p>The Y combinator is a higher-order function that takes a single
argument, which is a <em>function</em> that <strong>isn&rsquo;t</strong> recursive and returns a
version of the same function that <em>is</em> recursive.</p>
<p>If that is not enough to blow your mind, please: <em>What do you think
recursion is?</em></p>
<p>More generally, Y gives us a way to get recursion in a programming
language that supports first-class functions but doesn&rsquo;t have
recursion built in.</p>
<h1 id="introduction">Introduction</h1>
<p align="center">
  <img src="https://theburningmonk.com/wp-content/uploads/2017/08/recursion-01.png" />
</p>
<p>This post will be a comprehensive walk through the Chapter 9 of the
Little Schemer book. The idea is to reproduce the same discussion
about recursive functions and get us straight to the <em>Y combinator</em>
definition. I will also be using <em>Clojure</em> and borrowing some
explanations from this amazing
<a href="https://mvanier.livejournal.com/2897.html">article</a>.</p>
<h2 id="part-1-partial-functions-and-unnatural-recursion">Part 1: Partial Functions and Unnatural Recursion</h2>
<p>Partial functions have this strange property of being correct for
<em>some</em> input values and to have no guarantees that it will produce the
correct answer to others.</p>
<p>For example the <code>looking</code> function below:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">looking</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">lat</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">keep-looking</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">first </span><span class="nv">lat</span><span class="p">)</span> <span class="nv">lat</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">keep-looking</span> <span class="p">[</span><span class="nb">val index </span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">new-val</span> <span class="p">(</span><span class="nb">get </span><span class="nv">coll</span> <span class="p">(</span><span class="nb">- index </span><span class="mi">1</span><span class="p">))]</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">(</span><span class="nb">= </span><span class="nv">new-val</span> <span class="nv">val</span><span class="p">)</span>
      <span class="nv">true</span>
      <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">integer?</span> <span class="nv">new-val</span><span class="p">))</span>
      <span class="nv">false</span>
      <span class="ss">:else</span>
      <span class="p">(</span><span class="nf">keep-looking</span> <span class="nb">val </span><span class="nv">new-val</span> <span class="nv">coll</span><span class="p">))))</span>
</code></pre></div><p>Give it a <code>:keyword</code> and a <code>collection</code> and the <code>looking</code> function
will get the first element of the collection and verify if it is equal
to the <code>:keyword</code> I passed. If true, returns true.</p>
<p>If false, use the first element of the collection to perform an <code>index</code>
lookup.</p>
<p>For example:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">lat</span> <span class="p">[</span><span class="mi">6</span> <span class="mi">2</span> <span class="mi">4</span> <span class="ss">:caviar</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="nf">looking</span> <span class="ss">:caviar</span> <span class="nv">lat</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="nv">true</span>
</code></pre></div><p>The path traveled by <code>looking</code> is:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">6th index --&gt; 7th index --&gt; 3rd index --&gt; 4th index <span class="o">(</span>which is my keyword<span class="o">)</span>
</code></pre></div><p>However the following example do not have an answer:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">lat3</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">1</span> <span class="mi">2</span> <span class="ss">:caviar</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="nf">looking</span> <span class="ss">:caviar</span> <span class="nv">lat3</span><span class="p">)</span>
</code></pre></div><p>The path:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">7th index --&gt; 3rd index --&gt; 2nd index --&gt; 1st index --&gt; 7th index ---&gt; ...
</code></pre></div><p>There are many functions like this. We are going to use the same class
of functions to develop the idea of the Y combinator.  Why? They
appears when you have the huge constrain of not being able to <code>define</code>
anything.</p>
<p>Think about it, if you understand recursion as the technique of
defining some function <em>f</em> in terms of itself. Then, if you can&rsquo;t
<code>define</code> the name of the function in your programming language, it
will be &ldquo;&ldquo;impossible&rdquo;&rdquo; to write a recursive call, right?</p>
<h2 id="part-2-lets-get-into-it">Part 2: Let&rsquo;s get into it!</h2>
<p>We are going to use the <code>length</code> function below in order to build our
way through the Y Combinator function.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">length</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
    <span class="mi">0</span>
    <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</code></pre></div><p>However, without the <code>define</code> constructor we can&rsquo;t write the name
<code>length</code> inside the body of the function because there is no way to
refer to the name of this function yet, it will be written as an
anonymous function.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
    <span class="mi">0</span>
    <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">?????</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</code></pre></div><p>We still cannot write a better function to replace <code>?????</code>, however
the real question is: <em>the function above is all useless?</em>*</p>
<p>Actually, not.</p>
<p>The following call will produce the correct value:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">???</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span> <span class="p">())</span> <span class="c1">; call with the empty list</span>
<span class="c1">;; =&gt; 0</span>
</code></pre></div><p><em>IF</em> we could <code>define</code> the function above, we could called it
<code>length-0</code> because it correctly returns the length of the empty
list. However, is also possible to use this new <code>length-0</code> function to
write a new version which returns the correct answer to a list with
only <em>one</em> element.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">length-0</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">?????</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>

<span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
     <span class="mi">0</span>
     <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length-0</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span> <span class="p">(</span><span class="nb">list </span><span class="ss">:A</span><span class="p">))</span>
<span class="c1">;; =&gt; 1</span>
</code></pre></div><p>But, let&rsquo;s pretend we can&rsquo;t use <code>define</code> here, so the last function
will become (I am only doing a substitution of the <code>length-0</code>
function):</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
    <span class="mi">0</span>
    <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
              <span class="mi">0</span>
              <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">?????</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
          <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</code></pre></div><p>Ok, let&rsquo;s pay attention to the function above.</p>
<p>It cannot only answer correctly the length of a list with a single
item, also correctly answers when the input list is <em>UP to 1
element</em>. Therefore the empty list will also return the correct value.</p>
<p>Now, let&rsquo;s take another step on that direction, let&rsquo;s build the
function that will return correctly when the input is <em>UP to 2
elements</em>:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
    <span class="mi">0</span>
    <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
              <span class="mi">0</span>
              <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
                      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
                        <span class="mi">0</span>
                        <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">?????</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
                    <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
          <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</code></pre></div><p>UP to 3 elements:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
    <span class="mi">0</span>
    <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
              <span class="mi">0</span>
              <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
                      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
                        <span class="mi">0</span>
                        <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
                                <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
                                  <span class="mi">0</span>
                                  <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">?????</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
                              <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
                    <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</code></pre></div><p>UP to 4 elements:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
    <span class="mi">0</span>
    <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
              <span class="mi">0</span>
              <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
                      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
                        <span class="mi">0</span>
                        <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
                                <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
                                  <span class="mi">0</span>
                                  <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
                                          <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
                                            <span class="mi">0</span>
                                            <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">?????</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
                                        <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
                              <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
                    <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
          <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>
</code></pre></div><p>And now, Friedman asks you:</p>
<h2 id="now-what-do-you-think-recursion-is">Now, what do you think recursion is?</h2>
<p>and that is a tough question.</p>
<p>Looks like if you pile a lot of &ldquo;incomplete&rdquo; functions that <em>for some</em>
primitive values returns the correct answer, we can get along just
fine.</p>
<p>Following this example, it looks like we could compute the length of
any list if we knew beforehand the size of the list and we could pile
the exact amount of <em>incomplete</em> functions ahead of time.</p>
<p><em>Crazy.. if you knew the size, you could pile the exact same amount of
stacks to compute the size recursively. How nice is that&hellip; o.O</em></p>
<p>Let&rsquo;s organize the code above and abstract the <code>?????</code> function from
the implementation.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func-length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
 <span class="nv">?????</span><span class="p">)</span>
</code></pre></div><p>Ok, the function above is important&hellip;It is another version of the
<code>length-0</code> function. The only difference here is that: <strong>as I don&rsquo;t know
the function <code>?????</code>, it could be &ldquo;anything&rdquo;, so I will abstract that
<em>out</em> of my main function and receive it as an argument</strong></p>
<p>Something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">main-function</span> <span class="nv">?????</span><span class="p">)</span> <span class="c1">;; got it?</span>
</code></pre></div><p>Ok, the new versions of the length up to 2 and 3 elements will be:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="c1">;; length-1</span>
<span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func-length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>


 <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func2-length</span><span class="p">]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func2-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
   <span class="nv">?????</span><span class="p">))</span>


<span class="c1">;; length-2</span>
<span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func-length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>


 <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func2-length</span><span class="p">]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func2-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>


  <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func3-length</span><span class="p">]</span>
     <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
       <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
         <span class="mi">0</span>
         <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func3-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
   <span class="nv">?????</span><span class="p">)))</span>


<span class="c1">;; length-3</span>
<span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func-length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>


 <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func2-length</span><span class="p">]</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func2-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>


  <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func3-length</span><span class="p">]</span>
     <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
       <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
         <span class="mi">0</span>
         <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func3-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>

   <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">func4-length</span><span class="p">]</span>
      <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
          <span class="mi">0</span>
          <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">func4-length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
    <span class="nv">?????</span><span class="p">))))</span>
</code></pre></div><p>Let&rsquo;s try to remove all the repetition above, let&rsquo;s rewrite the
<code>length-0</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">?????</span><span class="p">))</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))))</span>
</code></pre></div><p>Let&rsquo;s follow the calls of the function above in order to see how it
works to compute the length of the EMPTY list.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="c1">;;; the first parenthesis has 2 main blocks:</span>
<span class="c1">;; the function - Let&#39;s call it func0</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">?????</span><span class="p">))</span>

<span class="c1">;; and the argument. Let&#39;s call it arg0</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">length</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>

<span class="c1">;;; so the first call will be (func0 arg0)</span>

<span class="c1">;;; ok, now he will have the second level of calls</span>

<span class="c1">;; (arg0 ?????)</span>
<span class="c1">;; however, this level expand to another function like:</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
    <span class="mi">0</span>
    <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">?????</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))</span>

<span class="c1">;; behold.. this is our first version of `length-0`</span>
</code></pre></div><p>Ok, take some time to process this new notation. It only gets worse.</p>
<p>Now, how can we write the <code>length-1</code> and <code>length-2</code> using the concise
definition above?</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="c1">;; length-1</span>
<span class="p">(</span>
 <span class="c1">;; func</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">mk-length</span>
     <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">?????</span><span class="p">)))</span>

 <span class="c1">;; arg</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
 <span class="p">)</span>


<span class="c1">;; length-2</span>
<span class="p">(</span>
 <span class="c1">;; func</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">mk-length</span>
    <span class="p">(</span><span class="nf">mk-length</span>
     <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">?????</span><span class="p">))))</span>

 <span class="c1">;; arg</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
 <span class="p">)</span>
</code></pre></div><p>Wait a second&hellip; what just happened? It looks like the amount of
levels we need to build <em>DOES NOT DEPEND OF THE TASK AT
HAND</em>. WoW.. we factor out the <code>length</code>-specific portion of the code
and we started to pile up some sort of stack of incomplete calls.</p>
<p>Up to this point, everything was fine. Now, the magic starts to kick-in.
The problem at hand is that we don&rsquo;t know beforehand how many calls of
<code>mk-length</code> we will need to do when we receive any list to perform the
<code>length</code> operation.</p>
<p>If we choose a lower number of <code>mk-length</code> to perform the <code>length</code>
task, we will receive an error because it will try to call the <code>?????</code>
function by passing the argument <code>(rest coll)</code> to it, but <code>?????</code> does
not exist. &hellip; Friedman suggests&hellip; let&rsquo;s substitute the function
<code>?????</code>  for another call of <code>mk-length</code>&hellip; :X&hellip;. :X &hellip; afterwards
<code>mk-length</code> creates another &ldquo;stack of calls&rdquo; to enable us to compute
one extra element in the list.</p>
<p>Ok&hellip;</p>
<p>&hellip;</p>
<p>Now, the <code>length-0</code> will become:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">))</span>

 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))))</span>
</code></pre></div><p>So, if we apply <code>mk-length</code> one time, we will have <code>length-1</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">))</span>

 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="nf">mk-length</span> <span class="nv">?????</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
 <span class="p">)</span>
</code></pre></div><p>The above code is working equivalently to <code>length-1</code>, but it will
failed for a list with 2 elements. However, let&rsquo;s get wild. <em>keep
passing <code>mk-length</code> to itself&hellip;</em>, you will create as many frames as
you need&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span>
<span class="c1">;;; func0</span>
<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
     <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">))</span>

<span class="c1">;;; arg0</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
     <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
       <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
         <span class="mi">0</span>
         <span class="p">(</span><span class="nb">inc </span><span class="p">((</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
   <span class="p">)</span>
</code></pre></div><p>Are you kidding me&hellip; there is a problem though. The second function,
<code>arg0</code> in the comments above, does not remember the function that
actually computes the <code>length</code> operation as we started.</p>
<p>So, let&rsquo;s get rid of the <code>(mk-length mk-length)</code> call in there. Just
add another layer of function call and abstract that away.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
     <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">))</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
   <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">length</span><span class="p">]</span>
       <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
           <span class="mi">0</span>
           <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
    <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">))))</span>
</code></pre></div><p>However, if you run the code above.. it will give you an
<code>StackOverflow Error</code> because you are applying <code>mk-length</code> to itself
indefinitely. What you need to do is a &ldquo;lazy&rdquo; call, only call it when
needed. So you must wrap it under another function call layer.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
     <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">))</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
   <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">length</span><span class="p">]</span>
       <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
           <span class="mi">0</span>
           <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">))))))</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
      <span class="p">((</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))))</span>
</code></pre></div><p>Alright, the next step is just re-arranging the code to factor out the
portion of the code that is related to the <code>length</code> operation that we
desire.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="c1">;;func0</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">non-recursive-func</span><span class="p">]</span>
   <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
      <span class="p">(</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">))</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">mk-length</span><span class="p">]</span>
      <span class="p">(</span><span class="nf">non-recursive-func</span>
       <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
         <span class="p">((</span><span class="nf">mk-length</span> <span class="nv">mk-length</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))))</span>

 <span class="c1">;;; arg0</span>
 <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">length</span><span class="p">]</span>
   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">coll</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">coll</span><span class="p">)))))))</span>
</code></pre></div><p>Congratulations&hellip; <code>func0</code> above is the Y combinator function. It
receives one function and return another function which is recursive.</p>
<p>Changing the name of the variables:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">Y</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">non-recursive-func</span><span class="p">]</span>
    <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">f</span><span class="p">))</span>
     <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span>
       <span class="p">(</span><span class="nf">non-recursive-func</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">((</span><span class="nf">f</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))))))</span>
</code></pre></div><p>This chapter of The Little Schemer could not have ended better:</p>
<p><strong>Q: Do you now know why Y works?</strong></p>
<p><strong>A: Read this chapter just one more time and you will.</strong></p>
</article>

        </main><footer id="footer">
    Copyright © 2020 Wanderson Ferreira
</footer>
</body>
</html>
